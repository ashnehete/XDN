package edu.umass.cs.xdn.docker;

import edu.umass.cs.xdn.interfaces.XDNContainer;
import org.json.JSONArray;
import org.json.JSONException;
import org.json.JSONObject;

import java.util.ArrayList;
import java.util.List;

public class DockerContainer implements XDNContainer {

    /**
     * The name of the docker
     */
    final String name;

    /**
     * Docker hub url
     */
    final String imageUrl;

    /**
     * The port number exposed to the public network
     */
    final int port;

    /**
     *
     */
    final int exposePort;

    /**
     * This is long unique id generated by docker.
     */
    String id;

    /**
     *
     */
    String addr;

    /**
     *
     */
    final private List<String> serviceNames;

    /**
     * Environment variables for container
     */
    JSONArray env;

    /**
     * If there is a HTTP interface with the application
     */
    boolean httpInterface;

    /**
     * Docker image name of HTTP interface
     */
    String httpImageUrl;

    /**
     * Docker image port of HTTP interface
     */
    int httpPort;

    /**
     * Docker expose port of HTTP interface
     */
    int httpExposePort;

    /**
     * Env variables for the HTTP interface docker container
     */
    JSONArray httpEnv;


    /**
     * Indicate whether the docker uses a volume
     * Volume is the docker volume attached to the running instance
     * We let volume name be same as name, which is unique across all apps.
     */
    final private String volume;

    private String xdnFormat = null;

    /**
     * @param name
     * @param imageUrl
     * @param port
     * @param exposePort
     * @param env
     * @param volume
     */
    public DockerContainer(String name, String imageUrl, int port, int exposePort, JSONArray env, String volume) {
        this.name = name;
        this.volume = volume;
        this.imageUrl = imageUrl;
        this.port = port;
        this.exposePort = exposePort;
        this.env = env;
        this.serviceNames = new ArrayList<>();
    }

    /**
     * @param name
     * @param imageUrl
     * @param port
     * @param exposePort
     * @param env
     * @param volume
     * @param xdnFormat
     */
    public DockerContainer(String name, String imageUrl, int port, int exposePort, JSONArray env, String volume, String xdnFormat) {
        this(name, imageUrl, port, exposePort, env, volume);
        this.xdnFormat = xdnFormat;
    }

    public DockerContainer(String name, String imageUrl, int port, int exposePort, JSONArray env, String volume, String xdnFormat, String httpImageUrl, int httpPort, int httpExposePort, JSONArray httpEnv) {
        this(name, imageUrl, port, exposePort, env, volume, xdnFormat);
        this.httpImageUrl = httpImageUrl;
        this.httpPort = httpPort;
        this.httpExposePort = httpExposePort;
        this.httpEnv = httpEnv;
    }


    public DockerContainer(JSONObject json) throws JSONException {
        this.name = json.getString(DockerKeys.NAME.toString());
        this.volume = json.getString(DockerKeys.VOL.toString());
        this.env = json.getJSONArray(DockerKeys.ENV.toString());
        this.imageUrl = json.getString(DockerKeys.IMAGE_URL.toString());
        this.port = json.getInt(DockerKeys.PORT.toString());
        this.exposePort = json.getInt(DockerKeys.PUBLIC_EXPOSE_PORT.toString());
        this.xdnFormat = json.getString(DockerKeys.XDN_FORMAT.toString());
        JSONArray users = json.getJSONArray(DockerKeys.SERVICE_NAMES.toString());
        this.serviceNames = new ArrayList<>();
        if (users != null) {
            for (int i = 0; i < users.length(); i++) {
                serviceNames.add(users.getString(i));
            }
        }

        this.httpInterface = json.getBoolean(DockerKeys.HTTP_INTERFACE.toString());
        if (this.httpInterface) {
            this.httpImageUrl = json.getString(DockerKeys.HTTP_IMAGE_URL.toString());
            this.httpPort = json.getInt(DockerKeys.HTTP_PORT.toString());
            this.httpExposePort = json.getInt(DockerKeys.HTTP_PUBLIC_EXPOSE_PORT.toString());
            this.httpEnv = json.getJSONArray(DockerKeys.HTTP_ENV.toString());
        }
    }

    public JSONObject toJSONObject() throws JSONException {
        JSONObject json = new JSONObject();

        json.put(DockerKeys.NAME.toString(), name);
        json.put(DockerKeys.ENV.toString(), env);
        json.put(DockerKeys.IMAGE_URL.toString(), imageUrl);
        json.put(DockerKeys.PORT.toString(), port);

        JSONArray snJSON = new JSONArray(serviceNames);
        json.put(DockerKeys.SERVICE_NAMES.toString(), snJSON);

        return json;
    }


    public void setAddr(String addr) {
        this.addr = addr;
    }

    public String getAddr() {
        return addr;
    }

    public int getPort() {
        return port;
    }

    public int getExposePort() {
        return exposePort;
    }

    public void setID(String id) {
        this.id = id;
    }

    public String getID() {
        return id;
    }

    public String getXdnFormat() {
        return xdnFormat;
    }

    public void setXdnFormat(String xdnFormat) {
        this.xdnFormat = xdnFormat;
    }

    @Override
    public List<String> getStartCommand(String name) {
        return null;
    }

    @Override
    public List<String> getCheckpointCommand(String name) {
        return null;
    }

    @Override
    public List<String> getRestoreCommand(String name) {
        return null;
    }

    @Override
    public List<String> getStopCommand(String name) {
        return null;
    }

    @Override
    public List<String> getPullCommand(String name, boolean exists) {
        return null;
    }

    public void addServiceName(String name) {
        serviceNames.add(name);
    }

    public boolean removeServiceName(String name) {
        return serviceNames.remove(name);
    }

    public boolean isEmpty() {
        return serviceNames.isEmpty();
    }

    public String getName() {
        return name;
    }

    public String getUrl() {
        return imageUrl;
    }

    public String getVolume() {
        return volume;
    }

    public JSONArray getEnv() {
        return env;
    }

    public static JSONObject dockerToJsonState(DockerContainer container) {
        JSONObject json = new JSONObject();

        try {
            json.put(DockerKeys.NAME.toString(), container.name);
            json.put(DockerKeys.IMAGE_URL.toString(), container.imageUrl);
            // json.put(DockerKeys.SERVICE_NAMES.toString(), container.serviceNames);
            json.put(DockerKeys.VOL.toString(), container.volume);
            json.put(DockerKeys.PORT.toString(), container.port);
            json.put(DockerKeys.PUBLIC_EXPOSE_PORT.toString(), container.exposePort);
            json.put(DockerKeys.ENV.toString(), container.env);
            if (container.xdnFormat != null) json.put(DockerKeys.XDN_FORMAT.toString(), container.xdnFormat);

        } catch (Exception e) {
            e.printStackTrace();
        }

        // System.out.println("############ JSON State:" + json);
        return json;
    }

    public static DockerContainer stateToDockerContainer(JSONObject json) throws Exception {

        String appName = json.getString(DockerKeys.NAME.toString());
        int port = json.has(DockerKeys.PORT.toString()) ? json.getInt(DockerKeys.PORT.toString()) : -1;
        String url = json.has(DockerKeys.IMAGE_URL.toString()) ? json.getString(DockerKeys.IMAGE_URL.toString()) : null;
        JSONArray jEnv = json.has(DockerKeys.ENV.toString()) ? json.getJSONArray(DockerKeys.ENV.toString()) : null;
        String vol = json.has(DockerKeys.VOL.toString()) ? json.getString(DockerKeys.VOL.toString()) : null;
        int exposePort = json.has(DockerKeys.PUBLIC_EXPOSE_PORT.toString()) ? json.getInt(DockerKeys.PUBLIC_EXPOSE_PORT.toString()) : 80;
        String xdnFormat = json.has(DockerKeys.XDN_FORMAT.toString()) ? json.getString(DockerKeys.XDN_FORMAT.toString()) : null;

        return new DockerContainer(appName, url, port, exposePort, jEnv, vol, xdnFormat);
    }

    public static void main(String[] args) {

    }

}
